"use strict";
/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EXECUTE_TX_DISCRIMINATOR = void 0;
exports.getExecuteTxDiscriminatorBytes = getExecuteTxDiscriminatorBytes;
exports.getExecuteTxInstructionDataEncoder = getExecuteTxInstructionDataEncoder;
exports.getExecuteTxInstructionDataDecoder = getExecuteTxInstructionDataDecoder;
exports.getExecuteTxInstructionDataCodec = getExecuteTxInstructionDataCodec;
exports.getExecuteTxInstructionAsync = getExecuteTxInstructionAsync;
exports.getExecuteTxInstruction = getExecuteTxInstruction;
exports.parseExecuteTxInstruction = parseExecuteTxInstruction;
const kit_1 = require("@solana/kit");
const programs_1 = require("../programs");
const shared_1 = require("../shared");
exports.EXECUTE_TX_DISCRIMINATOR = new Uint8Array([
    249, 17, 145, 23, 12, 252, 17, 41,
]);
function getExecuteTxDiscriminatorBytes() {
    return (0, kit_1.fixEncoderSize)((0, kit_1.getBytesEncoder)(), 8).encode(exports.EXECUTE_TX_DISCRIMINATOR);
}
function getExecuteTxInstructionDataEncoder() {
    return (0, kit_1.transformEncoder)((0, kit_1.getStructEncoder)([["discriminator", (0, kit_1.fixEncoderSize)((0, kit_1.getBytesEncoder)(), 8)]]), (value) => (Object.assign(Object.assign({}, value), { discriminator: exports.EXECUTE_TX_DISCRIMINATOR })));
}
function getExecuteTxInstructionDataDecoder() {
    return (0, kit_1.getStructDecoder)([
        ["discriminator", (0, kit_1.fixDecoderSize)((0, kit_1.getBytesDecoder)(), 8)],
    ]);
}
function getExecuteTxInstructionDataCodec() {
    return (0, kit_1.combineCodec)(getExecuteTxInstructionDataEncoder(), getExecuteTxInstructionDataDecoder());
}
function getExecuteTxInstructionAsync(input, config) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d;
        // Program address.
        const programAddress = (_a = config === null || config === void 0 ? void 0 : config.programAddress) !== null && _a !== void 0 ? _a : programs_1.SOLANA_CORE_MULTISIG_PROGRAM_ADDRESS;
        // Original accounts.
        const originalAccounts = {
            multisig: { value: (_b = input.multisig) !== null && _b !== void 0 ? _b : null, isWritable: true },
            multisigSigner: { value: (_c = input.multisigSigner) !== null && _c !== void 0 ? _c : null, isWritable: false },
            transaction: { value: (_d = input.transaction) !== null && _d !== void 0 ? _d : null, isWritable: true },
        };
        const accounts = originalAccounts;
        // Resolve default values.
        if (!accounts.multisigSigner.value) {
            accounts.multisigSigner.value = yield (0, kit_1.getProgramDerivedAddress)({
                programAddress,
                seeds: [
                    (0, kit_1.getBytesEncoder)().encode(new Uint8Array([109, 117, 108, 116, 105, 115, 105, 103])),
                    (0, kit_1.getAddressEncoder)().encode((0, shared_1.expectAddress)(accounts.multisig.value)),
                ],
            });
        }
        const getAccountMeta = (0, shared_1.getAccountMetaFactory)(programAddress, "programId");
        const instruction = {
            accounts: [
                getAccountMeta(accounts.multisig),
                getAccountMeta(accounts.multisigSigner),
                getAccountMeta(accounts.transaction),
            ],
            programAddress,
            data: getExecuteTxInstructionDataEncoder().encode({}),
        };
        return instruction;
    });
}
function getExecuteTxInstruction(input, config) {
    var _a, _b, _c, _d;
    // Program address.
    const programAddress = (_a = config === null || config === void 0 ? void 0 : config.programAddress) !== null && _a !== void 0 ? _a : programs_1.SOLANA_CORE_MULTISIG_PROGRAM_ADDRESS;
    // Original accounts.
    const originalAccounts = {
        multisig: { value: (_b = input.multisig) !== null && _b !== void 0 ? _b : null, isWritable: true },
        multisigSigner: { value: (_c = input.multisigSigner) !== null && _c !== void 0 ? _c : null, isWritable: false },
        transaction: { value: (_d = input.transaction) !== null && _d !== void 0 ? _d : null, isWritable: true },
    };
    const accounts = originalAccounts;
    const getAccountMeta = (0, shared_1.getAccountMetaFactory)(programAddress, "programId");
    const instruction = {
        accounts: [
            getAccountMeta(accounts.multisig),
            getAccountMeta(accounts.multisigSigner),
            getAccountMeta(accounts.transaction),
        ],
        programAddress,
        data: getExecuteTxInstructionDataEncoder().encode({}),
    };
    return instruction;
}
function parseExecuteTxInstruction(instruction) {
    if (instruction.accounts.length < 3) {
        // TODO: Coded error.
        throw new Error("Not enough accounts");
    }
    let accountIndex = 0;
    const getNextAccount = () => {
        const accountMeta = instruction.accounts[accountIndex];
        accountIndex += 1;
        return accountMeta;
    };
    return {
        programAddress: instruction.programAddress,
        accounts: {
            multisig: getNextAccount(),
            multisigSigner: getNextAccount(),
            transaction: getNextAccount(),
        },
        data: getExecuteTxInstructionDataDecoder().decode(instruction.data),
    };
}
