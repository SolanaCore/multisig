"use strict";
/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.expectSome = expectSome;
exports.expectAddress = expectAddress;
exports.expectProgramDerivedAddress = expectProgramDerivedAddress;
exports.expectTransactionSigner = expectTransactionSigner;
exports.getAccountMetaFactory = getAccountMetaFactory;
exports.isTransactionSigner = isTransactionSigner;
const kit_1 = require("@solana/kit");
/**
 * Asserts that the given value is not null or undefined.
 * @internal
 */
function expectSome(value) {
    if (value == null) {
        throw new Error("Expected a value but received null or undefined.");
    }
    return value;
}
/**
 * Asserts that the given value is a PublicKey.
 * @internal
 */
function expectAddress(value) {
    if (!value) {
        throw new Error("Expected a Address.");
    }
    if (typeof value === "object" && "address" in value) {
        return value.address;
    }
    if (Array.isArray(value)) {
        return value[0];
    }
    return value;
}
/**
 * Asserts that the given value is a PDA.
 * @internal
 */
function expectProgramDerivedAddress(value) {
    if (!value || !Array.isArray(value) || !(0, kit_1.isProgramDerivedAddress)(value)) {
        throw new Error("Expected a ProgramDerivedAddress.");
    }
    return value;
}
/**
 * Asserts that the given value is a TransactionSigner.
 * @internal
 */
function expectTransactionSigner(value) {
    if (!value || !isTransactionSigner(value)) {
        throw new Error("Expected a TransactionSigner.");
    }
    return value;
}
/**
 * Get account metas and signers from resolved accounts.
 * @internal
 */
function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
    return (account) => {
        if (!account.value) {
            if (optionalAccountStrategy === "omitted")
                return;
            return Object.freeze({
                address: programAddress,
                role: kit_1.AccountRole.READONLY,
            });
        }
        const writableRole = account.isWritable
            ? kit_1.AccountRole.WRITABLE
            : kit_1.AccountRole.READONLY;
        return Object.freeze(Object.assign({ address: expectAddress(account.value), role: isTransactionSigner(account.value)
                ? (0, kit_1.upgradeRoleToSigner)(writableRole)
                : writableRole }, (isTransactionSigner(account.value) ? { signer: account.value } : {})));
    };
}
function isTransactionSigner(value) {
    return (!!value &&
        typeof value === "object" &&
        "address" in value &&
        (0, kit_1.isTransactionSigner)(value));
}
